<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozási tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Juhász István - Magas szintű programozási nyelvek 1</title>
        <para>
            <citation>PICI</citation>
        </para>
        <para>
            Alapfogalmak:
        </para>
        <para>
            Gépi nyelv: A gépi nyelv, egy olyan nyelv, amely a számítógép számára közvetlenül értelmezhető.
            Kettes vagy tizenhatos számrendszeren alapul (számokkal ábrázolandó). 
        </para>
        <para>
            Magas szintű nyelv: A magas szintű programozási nyelvek már felhasználó közelibbek. Ezek nem értelmezhetőek 
            közvetlenül a számítógép által. Itt már szükségünk van egy fordítóra, ami lefordítja gépi nyelvre, ahhoz, hogy 
            futtatható legyen.
        </para>
        <para>
            Gépi nyelvezetű avagy alacsony szintű programnyelv például az Assembly, amelyben sokkal nehezebben igazodunk el, 
            hisz egyértelműen látszik, hogy a géphez áll közelebb. Viszont magas szintű programnyelv például a C, amelyben 
            érzékelhetjük is, hogy sokkal jobban érthetőek a C-ben írt kódok, mint akár Assembly-ben. Hisz C-ben mondhatjuk, 
            hogy angol kulcsszavakkal adunk ki "parancsokat" a számítógép számára, ami persze ugyanúgy lefordul majd gépi 
            kódra, aztán futtathatóvá is válik.
        </para>
        <para>
            Egy programot tudunk szintaktikailag, illetve szemantikailag elemezni. Szintaktikai elemzésnél konkrétan a 
            programkódunk "helyesírására" figyelünk. Tehát, hogy nem-e írtunk el egy adott parancsot például, stb.. 
            Szemantikai elemzésnél már arra figyelünk, hogy miután szintaktikailag helyes a programunk, helyesen fut-e le. 
            Tehát itt azt nézzük, hogy tényleg azt csinálja-e a programunk, ami a célunk volt vele. Helyesen fut-e le.
        </para>
        <para>
            A programnyelveket két fő csoportba soroljuk: vannak imperatív és dekleratív nyelvek. Az imperatív nyelvek 
            általában az értékadó utasítások megfelelő sorrendben való kiadására koncentrálnak. Ez az a típus, amelyben 
            feltehetően többen programoznak, bár nem feltétlenül, de ha valaki komolyabb programozásra vágyik, ezzel a 
            típussal kezdi el a gyakorlást, majd folytatja a bonyolultabb programokkal. Imperatívak például az eljárásorientált 
            nyelvek, vagy az objektumorientált nyelvek.
        </para>
        <para>
            A dekleratív csoportba sorolható programkódoknál általában a programíró arra koncentrál, hogy mit szeretne 
            kapni az adott program futása során. Ilyenek például a funkcionális nyelvek, illetve a logikai nyelvek is.
        </para>
        <para>
            Fontos megjegyezni, hogy elméleti szinten nem fogunk megtanulni programozni. Ezalatt azt értem, hogy ahhoz, hogy 
            valaki jó programozóvá váljon, rengeteg programkódot kell átvészelnie mind elméletben, de legfőképpen gyakorlatban.
        </para>
        <para>
            Utasítások:
        </para>
        <para>
            Sokféle utasítás létezik. Ilyenek például az értékadó, üres, ugró, elágaztató, ciklusszervező, hívó, I/O illetve 
            számos egyéb utasítások.
        </para>
        <para>
            Itt azért pár utasítás eléggé magától értendő. Mint például az értékadó utasításokkal egy vagy több változó 
            értékkomponensét állítjuk be, vagy éppen módosítjuk.
        </para>
        <para>
            Az elágaztató utasítások például az if feltétellel kapcsolatos megoldásokat fedi le, azaz valamilyen feltételes, 
            kétirányú logikai utasítás. Ezekből vannak egyirányú, illetve többirányúak is. Ide tartozik a switch utasítás is.
        </para>
        <para>
            Ez a könyv összegezve egy erősen elméletorientált könyv. Az ilyesféle könyvek is nagyon sokat hozzá tudnak tenni a fejlődésünkhöz. Fontos, hogy tudjunk beszélni 
            is arról amit csinálunk, ne csak a gyakorlati pályán arassunk. Egy jó programozó nyelvbotlás nélkül közli társai felé a felmerült problémákat, ráadásul maga a 
            programozás nyelvén...
        </para>
    </section>
    
    <section>
        <title>Kernighan Ritchie - A C programozási nyelv</title>
        <para>
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            Ez a könyv egy tematikusan felépülő könyv, amely a C nyelv elsajátításához segíti hozzá olvasóját. Próbálja 
            megismertetni a C nyelvet elég erős szinten, próbál bizonyos keretek között picit mélyebben belemenni a dolgokba.
        </para>
        <para>
            Nagyon sok világhírű, avagy ismert programozó ismerte el ezt a könyvet. Több programozó generáció nőtt fel ezen a könyvön, és még manapság 
            is nagyon hasznosnak minősül, hiszen a könyv erősen pártolja a gondolkodásmód elsajátítását, miközben megtanít clean code-ot iratni az olvasójával. 
            Azt gondolom hihetetlenül jól megírt, logikusan felépített könyv. Pont annyira szól kezdőknek, amennyire kell, nagyon el lett találva.
        </para>
        <para>
            A könyv alapismeretekkel indít. Hamar lényegre is tör, hiszen már egy "Hello World!" stílusú program megírásával 
            szemléltet az olvasó felé. Erősen ragaszkodik a UNIX-on való fordításra, illetve futtatásra.
        </para>
        <para>
            Bemutatja a szokásos alap programozási eszközöket. Mint például ciklusok (for, while, do-while), a változó deklarálásától 
            megkezdve a tömbökön át a függvényekig. Kitér külön a változótípusokra, amik működését el is magyarázza, több példán keresztül bemutatja.
        </para>
        <para>
            Már viszonylag hamar elkezdődnek folyamatos rövid példákkal való szemléltetések, illetve a programkódok kipróbálásra való 
            késztetések. A fent leírtak mindegyike érthető módon be van mutatva, le van egyszerű programokba bonyolítva, amelyek 
            értelemszerűen a lehető legjobb megérttetésre törekednek. De hiszen nincs ezzel semmi baj, ez így van jól, így a helyes.
        </para>
        <para>
            Sok dolog magyarázatát a könyv eltolja 3-4-5 fejezettel későbbre, hiszen megértésüket számos más dolog megértése igényli.
        </para>
        <para>
            Az 1. fejezet tisztázza az alapokat, bár annak ellenére azért nem a legalapvetőbb programkódokkal szemléltet, ami kihívásérzetet kelt az emberben, és talán, 
            mivel az elején még egész jól megérthetőek szerintem akár egy laikus számára is, ezért hiába nehéz a feladat, nagyobb lesz a sikerérzete az olvasónak, ezáltal 
            kap egy hatalmas löketet, hogy haladjon tovább, és ez majdnemhogy végig motiválja az olvasót.
        </para>
        <para>
            A 2. fejezetben kitér a típusokra jobban, adattípusok, méretek, állandók, deklarációk, típuskonverziók, értékadó operátorok, kifejezések. Aztán a 3. fejezetben 
            már megjelennek a vezérlési szerkezetek, a feltételes kifejezések után már több if-else egymásban, switch, while, for, hátultesztelő ciklus. Itt már az olvasó 
            megismerkedhet a break, continue, goto utasításokkal.
        </para>
        <para>
            A 4. fejezet már jobban szóba kerülnek a függvények, szóba jönnek már fontosabb dolgok, amiket mindenképp meg kell értenünk a fejlődés hatékonysága érdekében. 
            Már szó van a rekurzióról, statikus változók, blokkstruktóra, inicializálás.
        </para>
        <para>
            Azt gondolom nem hiába volt már abban az időben is elterjed eme könyv olvasása. Nagyon lényegi módon vezeti rá az olvasót a megfelelő gondolkodás elsajátítására.
            Szokták mondani, hogy programozni nem fogsz egy könyvből megtanulni, más nem tudja neked megtanítani. Nahát erre a könyvre ez most pont nem klappol...
        </para>
    </section>
    
    <section>
        <title>Programozás</title>
        <para>
            <citation>BME konyv</citation>
        </para>
        <para>
            A könyv a C és C++ nyelvet mutatja be. Már a második részben a lényegre tér. Átveszi az alapvető tudnivalókat, közben összehasonlító módon 
            párhuzamosan íródik mindkét nyelvről. Ez azért is lehet érdekes számunkra, mert a C++ alapvetően egy objektumorientált nyelv, így C-vel összehasonlítva 
            elég sok eltérés lehet. Még akkor is, ha csak eggyel tér el "verziószámuk". 
        </para>
        <para>
            A C inkább alacsony szintű programnyelvnek mondható, mintsem magasnak. Hiszen mondhatjuk, hogy valamilyen szinten közel áll a géphez, talán még közelebb is, 
            mint az emberhez. C-ben rengeteg megoldás furcsa lehet azok számára, akik egyből erősen objektumorientált, magas szintű nyelvekkel ismerkedtek meg.
        </para>
        <para>
            Viszonylag hamar szó esik a függvények túlterheléséről. Az is egy érdekesség, hogy C-ben a nevük alapján azonosítunk egyértelműen egy függvényt, míg C++-ban 
            a nevük és argumentumlistájuk együttesen azonosítja. Tehát ez azt jelenti számunkra, hogy akár előfordulhat C++-ban azonos nevű függvény is.
        </para>
        <para>
            C++ nyelvben lehetőségünk van, hogy függvények argumentumainak alapértelmezett értéket adjunk meg. Amennyiben ezen argumentumoknak a függvény hívásakor nem 
            adunk értéket, az az alapértelmezett értékével kerül meghívásra. 
        </para>
        <para>
            Paraméter referenciatípussal: 
            C-ben kizárólag érték szerinti paraméterátadás történik, így az <function>f</function> függvény hívásakor az <function>a</function> változó értéke a veremre 
            másolódik, és erre kell hivatkoznunk az <function>i</function> szimbólummal az <function>f</function> függvényen belül. 
        </para>
        <para>
            A 3. részben már rá is tér a könyvünk az objektumokra és osztályokra. Ebben a fejezetben egész jól el van magyarázva az objektumorientáltság alapja.
            Már egyből egy érdekes felvetéssel kezdődik a fejezet, mégpedig, hogy a számítástecnika fejlődése során egyre jobban feltűnhet számunkra, hogy a szoftveren 
            húzódik le a súly. Hiszen manapság már ha megtudják tenni, inkább a hardvereken spórolnak hatalmasakat, és egyre jobban inkább optimalizálják a dolgokat, 
            mintsem inkább erősebb hardver legyen alatta. A kérdés az, hogy miért? Miért csinálják ezt a legtöbben? Csak azért, hogy minél nagyobb profitjuk lehessen?
        </para>
        <para>
            Mindenesetre ez egy egész jól sikerült chapter lett, szerintem teljesen jó irányból lett közelítve az objektumorientáltság, még akkor is, ha személy szerint 
            annyira még nem mentem bele a dolgokba.
        </para>
        <para>
            Mindezek ellenére azért nem mondhatjuk el, hogy lassú tempóban halad a könyv, alapelvárásnak tűnik, hogy önszorgalomból fejlődjünk a könyvvel, mintsem 
            szájbarágósan magyarázzon el minden egyes kis apró részletet. De jól is van ez így, hiszen ez a lényege a programozásnak, hogy önállóan sajátítsuk el, hiszen 
            máshogyan esélyünk sincs.
        </para>
        <para>
            Tagváltozók, tagfüggvények: ezen megnevezések a struktúra részei, adattagjai. Ez így összhangban van a C nyelv impelementációival is, ami szintén érdekes, hogy 
            . operátorokkal hivatkozhatunk tagváltozókra.
        </para>
        <para>
            Összességében ez a könyv eléggé gyors tempóban viszi végig a dolgokat. Érdemes egy erős alap után kézbe venni, hiszen anélkül túlságosan sok ismeretlen dologgal 
            találkoznánk, ami nem feltétlen lesz hatékony módszer a fejlődésre. Érdemes először belőni a szintünket, utána pedig cselekedni.
        </para>
    </section>
</chapter>